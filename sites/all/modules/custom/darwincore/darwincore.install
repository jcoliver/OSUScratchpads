<?php

/**
 * Implements hook_install().
 */
function darwincore_install(){
  // Clear the errors.
  drupal_get_messages('warning');
}

/**
 * Change the input format for the date collected field.
 */
function darwincore_update_7001(){
  $field_instance = field_info_instance('node', 'field_date_collected', 'specimen_observation');
  $field_instance['widget']['settings']['input_format'] = 'Y/m/d - H:i:s';
  field_update_instance($field_instance);
}

/**
 * Change the node_type table to reflect the bug in features.
 */
function darwincore_update_7002(){
  db_update('node_type')->fields(array(
    'base' => ''
  ))->condition('module', 'darwincore')->execute();
}

/**
 * Update the specimen/observation instance of the field_media field to alter
 * its display.
 */
function darwincore_update_7003(){
  $field_instance = field_info_instance('node', 'field_media', 'specimen_observation');
  $field_instance['display'] = array(
    'default' => array(
      'label' => 'above',
      'module' => 'file_entity',
      'settings' => array(
        'file_view_mode' => 'file_styles_square_thumbnail'
      ),
      'type' => 'file_rendered',
      'weight' => '12'
    ),
    'linked_node' => array(
      'label' => 'above',
      'settings' => array(),
      'type' => 'hidden',
      'weight' => 1
    ),
    'teaser' => array(
      'label' => 'above',
      'settings' => array(),
      'type' => 'hidden',
      'weight' => 0
    )
  );
  field_update_instance($field_instance);
}

/**
 * Update the specimen/observation instance of the field_media field to alter
 * the widget it uses.
 */
function darwincore_update_7004(){
  $field_instance = field_info_instance('node', 'field_media', 'specimen_observation');
  $field_instance['widget'] = array(
    'active' => 1,
    'module' => 'media_multiselect',
    'settings' => array(
      'allowed_schemes' => array(
        'module' => 0,
        'public' => 'public'
      ),
      'allowed_types' => array(
        'audio' => 'audio',
        'default' => 0,
        'image' => 'image',
        'video' => 'video'
      ),
      'browser_plugins' => array(
        'media_default--media_browser_1' => 0,
        'media_default--media_browser_my_files' => 0,
        'upload' => 0
      ),
      'progress_indicator' => 'throbber'
    ),
    'type' => 'media_multiselect',
    'weight' => '-3'
  );
  field_update_instance($field_instance);
}

/**
 * Update the user_reference fields so that they can actually be used!
 */
function darwincore_update_7005(){
  foreach(array(
    'field_collector',
    'field_identified_by'
  ) as $field_name){
    $field = field_info_field($field_name);
    if($field){
      $field['settings'] = array(
        'referenceable_roles' => array(),
        'referenceable_status' => array(),
        'view' => array(
          'view_name' => 'users_references',
          'display_name' => 'references_1',
          'args' => array()
        )
      );
      field_update_field($field);
    }
  }
}

/**
 * Set the collector field to be 1:n
 */
function darwincore_update_7006(){
  $field = field_info_field('field_collector');
  if($field){
    $field['cardinality'] = -1;
    field_update_field($field);
  }
}

/**
 * Update the user_reference fields for newly created sites since update 7005
 */
function darwincore_update_7007(){
  foreach(array(
    'field_collector',
    'field_identified_by'
  ) as $field_name){
    $field = field_info_field($field_name);
    if($field){
      $field['settings'] = array(
        'referenceable_roles' => array(),
        'referenceable_status' => array(),
        'view' => array(
          'view_name' => 'users_references',
          'display_name' => 'references_1',
          'args' => array()
        )
      );
      field_update_field($field);
    }
  }
}

/**
 * Update the display of the field_country field.
 */
function darwincore_update_7010(){
  // Update the display of the field_country field.
  module_load_include('features.field.inc', 'darwincore');
  $fields = darwincore_field_default_fields();
  foreach($fields as $key => $field){
    if(substr($key, 0, 13) == 'node-location'){
      if(field_info_field($field['field_instance']['field_name'])){
        field_update_instance($field['field_instance']);
      }
    }
  }
}

/**
 * Update the Widget used by the user reference fields
 * (field_identified_by and field_collector)
 */
function darwincore_update_7011(){
  $user_fields = array(
    'field_collector',
    'field_identified_by'
  );
  foreach($user_fields as $user_field){
    $info = field_info_field($user_field);
    // If the field doesn't exist, or isn't a user_reference (if the maintainers have changed it), skip it
    if(!$info || $info['type'] != 'user_reference'){
      continue;
    }
    $field_instance = field_info_instance('node', $user_field, 'specimen_observation');
    // If the field instance doesn't exist, or isn't using the widget we'd expect it to use
    // (if the maintainers have changed it), skip it
    if(!$field_instance || $field_instance['widget']['module'] != 'options' || $field_instance['widget']['type'] != 'options_select'){
      continue;
    }
    $field_instance['widget']['module'] = 'user_reference';
    $field_instance['widget']['type'] = 'user_reference_autocomplete';
    $field_instance['widget']['settings'] = array(
      'autocomplete_match' => 'contains',
      'autocomplete_path' => 'user_reference/autocomplete',
      'size' => '60'
    );
    field_update_instance($field_instance);
  }
}

/**
 * Update the specimen/observation instance of the field_genbank_number field.
 */
function darwincore_update_7012(){
  $field_instance = field_info_instance('node', 'field_genbank_number', 'specimen_observation');
  if($field_instance){
    $field_instance['label'] = 'GenBank number(s)';
    $field_instance['description'] = t('Enter a comma separated list of numbers. For example: FN554775, FR694013');
    $field_instance['display']['default']['type'] = 'darwincore_link_to_ncbi';
    field_update_instance($field_instance);
  }
}

/**
 * Ensure all fields exist, and lock them!
 */
function darwincore_update_7013(){
  $fields_to_lock = array();
  module_load_include('features.field.inc', 'darwincore');
  foreach(darwincore_field_default_fields() as $field){
    $fields_to_lock[] = $field['field_config']['field_name'];
    if(!field_info_field($field['field_config']['field_name'])){
      field_create_field($field['field_config']);
    }
    try{
      field_create_instance($field['field_instance']);
    }
    catch(Exception $e){
    }
  }
  db_update('field_config')->fields(array(
    'locked' => 1
  ))->condition('field_name', $fields_to_lock)->execute();
}
/**
 * Update the display of the Collector and Identified-By fields.
 */
function darwincore_update_7014(){
  module_load_include('features.field.inc', 'darwincore');
  $fields = darwincore_field_default_fields();
  field_update_instance($fields['node-specimen_observation-field_collector']['field_instance']);
  field_update_instance($fields['node-specimen_observation-field_identified_by']['field_instance']);
}

/**
 * Prepare for switch to GBIF names
 */
function darwincore_update_7015(){
  module_load_include('features.field.inc', 'darwincore');
  $definitions = darwincore_field_default_fields();
  $info = array(
    'node' => array(
      'specimen_observation' => array(
        'field_basis_of_record' => array(
          'map' => array(
            'Fossil Specimen' => 'FossilSpecimen',
            'Human Observation' => 'HumanObservation',
            'Living Specimen' => 'LivingSpecimen',
            'Preserved Specimen' => 'PreservedSpecimen',
            'Machine Observation' => 'MachineObservation',
            'Moving Image' => 'MachineObservation',
            'Other Specimen' => 'PreservedSpecimen',
            'Sound Recording' => 'MachineObservation',
            'Still Image' => 'MachineObservation',
            'Frozen specimen' => 'PreservedSpecimen',
            'Pinned Specimen' => 'PreservedSpecimen',
            'Specimen in vial' => 'PreservedSpecimen',
            'Specimen in vial (70% ethanol)' => 'PreservedSpecimen',
            'Specimen in vial + genital' => 'PreservedSpecimen'
          )
        ),
        'field_type_status' => array(
          'map' => array(
            'Holotype' => 'holotype',
            'Isotype' => 'isotype',
            'Lectotype' => 'lectotype',
            'Neotype' => 'neotype',
            'Nontype' => NULL,
            'nontype' => NULL,
            'Not Provided' => NULL,
            'Paralectotype' => 'paralectotype',
            'paraLectotype' => 'paralectotype',
            'Paratype' => 'paratype',
            'Syntype' => 'syntype',
            'Syntypes of T. pacificum wilsoni' => 'syntype',
            'Type status' => NULL,
            'Neotype' => 'neotype',
            'Not a Type' => 'notatype',
            'female' => NULL,
            '1 ex. holotype on slide 80/49 at Berlese Acaroteca, Cascine del Riccio, Firenze, Italy' => 'holotype',
            '1 ex., holotype on slide 23/9 inside finger-like air bubbles but recognizable, 1 ex. on 23/10, 1 ex. on 23/8 and 1 ex. on 23/11 in poor condition, 1 ex. on 23/7, useful, at Berlese Acaroteca, Cascine del Riccio, Firenze, Italy' => 'holotype',
            '3 females' => NULL,
            '3 specimens' => NULL,
            'des adultes des deux sexes (les mâles étant aussi nombreux que les femelles), les 3 sortes de nymphes et un exemplaire de la larve.' => NULL,
            'des adultes, les 3 sortes de nymphes et la larve. Les adultes étaient peu nombreux, et je n\'ai pu en examiner que 9 (8 femelles et 1 mâle)' => NULL,
            'female — Holotype and 2 females — paratypes' => NULL,
            'holotype as Alicus oblongus on a slide' => 'holotype',
            'holotype on slide N1952109' => 'holotype',
            'holotype on slide no. 20.02/7560' => 'holotype',
            'Holotype specimen # 2 of Protacarus crani Hirst, 1923' => 'holotype',
            'lost' => NULL,
            'male — Holotype, male — paratype, female — paratype and I paratype tritonymph' => 'type',
            'Material estudiado: Holotipo fem. (28 -X-81); 9 paratipos: 4 fem. (7-VIII-81; 28-X-81); 2 deutoninfas (7-VIII-81; 14-III-82) y 3 tritoninfas (20-XI-81; 14-III-82).' => 'type',
            'not stated' => NULL
          )
        )
      )
    )
  );
  // Add the new values to all the fields, so that they include both old set and new set
  foreach($info as $entity_type => $e_info){
    foreach($e_info as $bundle => $b_info){
      foreach($b_info as $field_name => $field_info){
        $field = field_info_field($field_name);
        if(!$field){
          unset($info[$entity_type][$bundle][$field_name]);
          continue;
        }
        $def_key = $entity_type . '-' . $bundle . '-' . $field_name;
        $old_values = $field['settings']['allowed_values'];
        $new_values = $definitions[$def_key]['field_config']['settings']['allowed_values'];
        $field['settings']['allowed_values'] = array_merge($old_values, $new_values);
        field_update_field($field);
        $info[$entity_type][$bundle][$field_name]['old'] = $old_values;
        $info[$entity_type][$bundle][$field_name]['new'] = $new_values;
        $info[$entity_type][$bundle][$field_name]['field'] = $field;
      }
    }
  }
  // Remap the old values in existing content, and add non-mapped values to the list of new values
  foreach($info as $entity_type => $e_info){
    foreach($e_info as $bundle => $b_info){
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', $entity_type);
      $efq->entityCondition('bundle', $bundle);
      $result = $efq->execute();
      if(empty($result[$entity_type])){
        continue;
      }
      $entities = entity_load($entity_type, array_keys($result[$entity_type]));
      foreach($entities as $entity){
        $save = FALSE;
        foreach($b_info as $field_name => $field_info){
          if(empty($entity->{$field_name})){
            continue;
          }
          $map = $field_info['map'];
          foreach($entity->{$field_name} as $language => $values){
            foreach($values as $delta => $value){
              $v = trim($value['value']);
              if(isset($map[$v]) && $map[$v] !== NULL){
                $entity->{$field_name}[$language][$delta]['value'] = $map[$v];
                $save = TRUE;
              }else if(isset($map[$v]) && $map[$v] === NULL){
                unset($entity->{$field_name}[$language][$delta]);
                $save = TRUE;
              }else if(!isset($field_info['new'][$value['value']])){
                // Re-insert it, the user will have to manually map this one.
                $info[$entity_type][$bundle][$field_name]['new'][$value['value']] = $field_info['old'][$value['value']];
              }
            }
          }
        }
        if($save){
          entity_save($entity_type, $entity);
        }
      }
    }
  }
  // Now re-save the fields with the final list of allowed values
  foreach($info as $entity_type => $e_info){
    foreach($e_info as $bundle => $b_info){
      foreach($b_info as $field_name => $field_info){
        // We can't use field_update_field because some of the values only change in case, and there is a
        // drupal bug that will stop us from saving the field - see https://drupal.org/node/2060275
        $new_field = $field_info['field'];
        $new_field['settings']['allowed_values'] = $field_info['new'];
        $data = $new_field;
        unset($data['columns'], $data['field_name'], $data['type'], $data['locked'], $data['module'], $data['cardinality'], $data['active'], $data['deleted']);
        unset($data['bundles']);
        $new_field['data'] = $data;
        $primary_key = array(
          'id'
        );
        drupal_write_record('field_config', $new_field, $primary_key);
        field_cache_clear(TRUE);
        module_invoke_all('field_update_field', $new_field, $field_info['field'], field_has_data($new_field));
      }
    }
  }
}