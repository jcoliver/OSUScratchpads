<?php
define("MIGRATE_NONE", 0);
define("MIGRATE_ALL", 1);
define("MIGRATE_CONTENT", 2);
define("MIGRATE_FIELD", 3);
define("SCRATCHPADS_MIGRATE_NOTIFICATIONS_EMAIL", 'd.koureas@nhm.ac.uk');
define("SCRATCHPADS_MIGRATE_SPAD1_SETTINGS_PATH", '/var/aegir/scratchpad_1_db_settings/');
/**
 * Run setup that must be executed at global level
 */
_scratchpads_migrate_settings();

/**
 * function _scratchapds_migrate_settings
 *
 * We cannot add the additional database connection into settings.php
 * as on the production server that file is manager by Aegir. Instead we
 * store these extra connection setting in a separate file, and load
 * it from there.
 * 
 * This must be called from the top execution level just as settings.php
 * would.
 */
function _scratchpads_migrate_settings(){
  global $base_url;
  global $s1_domain;
  // The domain of the site to migrate to would be:
  // - s2.DOMAIN (if we control the domain name) ;
  // - DOMAIN.myspecies.info (if we don't control the domain name) ;
  // - DOMAIN.migration.local (for local development)
  // - We accept DOMAIN for sites that have been moved but still have
  //   migration module enabled if the relevant DOMAIN.scratchpad_1.php
  //   file is present.
  $host = parse_url($base_url, PHP_URL_HOST);
  $s1_domain = $host;
  $is_dev = FALSE;
  if(strpos($host, 's2') === 0){
    $s1_domain = substr($host, 3);
  }else if(strpos($host, 'dev-s2') === 0){
    $s1_domain = substr($host, 7);
  }else if(preg_match('/\.myspecies\.info$/', $host)){
    $s1_domain = str_replace('.myspecies.info', '', $host);
  }else if(preg_match('/\.migration\.local$/', $host)){
    $s1_domain = str_replace('.migration.local', '', $host);
    $is_dev = TRUE;
  }
  $filename = SCRATCHPADS_MIGRATE_SPAD1_SETTINGS_PATH . $s1_domain . '.scratchpad_1.php';
  if(!file_exists($filename) && !$is_dev){
    // As we are running in top level, we can't rely on Drupal for error management.
    // It is better to cancel all processing now than to allow a broken migration install
    // to continue.
    echo "Migration error: Could not reliably determine Scratchpad 1 host name from the host name $host";
    exit(1);
  }
  if(file_exists($filename)){
    require_once ($filename);
  }else{
    // This connection will be picked up on local development sites which should have the right
    // definition in it's settings.php. If not this will provide a dummy connection
    // which will allow the Migrate module to bootstrap (but will not allow any migration
    // to happen).
    $connection_info = Database::getConnectionInfo();
    Database::addConnectionInfo('scratchpad_1', 'default', $connection_info['default']);
  }
}

/**
 * Implements hook_field_default_fields_alter().
 * 
 * Yes, this is a darwincore module hook.
 */
function darwincore_field_default_fields_alter(&$fields){
  unset($fields['node-specimen_observation-field_collector']);
  unset($fields['node-specimen_observation-field_identified_by']);
}

/**
 * Implements hook_flush_caches().
 */
function scratchpads_migrate_flush_caches(){
  scratchpads_migrate_register_migrations();
}

/**
 * Implements hook_migrate_api().
 */
function scratchpads_migrate_migrate_api(){
  return array(
    'api' => 2
  );
}

/**
 * Register all of the migrations for this module.
 */
function scratchpads_migrate_register_migrations(){
  $node_types = scratchpads_migrate_source_node_types();
  // Enable blog module
  if(in_array('blog', $node_types)){
    if(!module_exists('blog')){
      module_enable(array(
        'blog'
      ));
    }
  }
  // Enable the lexicon module if glossary module is installed
  if(scratchpads_migrate_source_module_exists('glossary')){
    if(!module_exists('scratchpads_lexicon')){
      module_enable(array(
        'scratchpads_lexicon'
      ));
    }
  }
  // The database connection to the Scratchpad 1 site.
  $common_arguments = array(
    'source_connection' => 'scratchpad_1',
    'source_version' => 6
  );
  /*********************************************************************************************
   * Citation
   ********************************************************************************************/
  if(scratchpads_migrate_source_table_exists('citation')){
    $arguments = $common_arguments + array(
      'description' => t('Migration of citations from Drupal 6'),
      'machine_name' => 'Citations',
      'group' => MigrateGroup::getInstance('setup')
    );
    Migration::registerMigration('CitationMigration', $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
       * Variables
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of variables from Drupal 6'),
    'machine_name' => 'Variable',
    'group' => MigrateGroup::getInstance('setup')
  );
  Migration::registerMigration('VariableMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Multi language
  ********************************************************************************************/
  if(scratchpads_migrate_source_table_exists('languages')){
    // Firstly, we ensure that the locale module is enabled.
    if(!module_exists('scratchpads_multilingual')){
      module_enable(array(
        'scratchpads_multilingual'
      ));
    }
    $arguments = $common_arguments + array(
      'description' => t('Migration of languages from Drupal 6'),
      'machine_name' => 'Language',
      'group' => MigrateGroup::getInstance('setup'),
      'dependencies' => array(
        'Variable'
      )
    );
    Migration::registerMigration('LanguageMigration', $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
   * User pictures
  ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of user pictures from Drupal 6'),
    'machine_name' => 'UserPicture',
    'group' => MigrateGroup::getInstance('setup')
  );
  Migration::registerMigration('ScratchpadsUserPictureMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
     * User
    ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of users from Drupal 6'),
    'machine_name' => 'User',
    'group' => MigrateGroup::getInstance('setup'),
    'dependencies' => array(
      'UserPicture'
    )
  );
  Migration::registerMigration('ScratchpadsUserMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * ContentTypes
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of content types from Drupal 6'),
    'machine_name' => 'ContentType',
    'dependencies' => array(
      'Vocabulary' // Vocabulary throws an error if not run first, so make content type dependent on it
    ),
    'group' => MigrateGroup::getInstance('setup')
  );
  Migration::registerMigration('DrupalContentTypeMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Vocabularies
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of vocabularies from Drupal 6'),
    'machine_name' => 'Vocabulary',
    'group' => MigrateGroup::getInstance('setup')
  );
  Migration::registerMigration('DrupalVocabularyMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Vocabulary fields
       ********************************************************************************************/
  $term_dependencies = array(
    'Vocabulary',
    'User'
  );
  foreach(scratchpads_migrate_get_term_vocabularies() as $vid => $term_node_type){
    $machine_name = scratchpads_migrate_get_machine_name('FieldVocabulary', $term_node_type);
    // Allow bespokes classes for different term nodes (with different fields)
    // We override the ITIS term class with our own as we know the field mappings
    $class_name = scratchpads_migrate_get_class_name($machine_name);
    if(!class_exists($class_name)){
      $class_name = 'DrupalFieldVocabularyMigration';
    }
    $arguments = $common_arguments + array(
      'description' => t('Migration of vocabulary fields from Drupal 6'),
      'machine_name' => $machine_name . $vid,
      'content_type' => $term_node_type,
      'vid' => $vid,
      'dependencies' => array(
        'Vocabulary'
      ),
      'group' => MigrateGroup::getInstance('fields', array(
        'setup'
      ))
    );
    $term_dependencies[] = $arguments['machine_name'];
    Migration::registerMigration($class_name, $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
       * Fields
       ********************************************************************************************/
  // The description and the migration machine name are also required arguments,
  // which will be unique for each migration you register.
  $arguments = $common_arguments + array(
    'description' => t('Migration of fields from Drupal 6'),
    'machine_name' => 'Field',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Body fields
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of body fields from Drupal 6'),
    'machine_name' => 'FieldBody',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldBodyMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Taxonomy fields
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of taxonomy fields from Drupal 6'),
    'machine_name' => 'FieldTaxonomy',
    'dependencies' => array(
      'ContentType',
      'Vocabulary'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  Migration::registerMigration('DrupalFieldTaxonomyMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Profile fields
       ********************************************************************************************/
  $user_dependencies = array();
  // If profile_fields table exists, add the FieldProfile migration
  if(scratchpads_migrate_source_table_exists('profile_fields')){
    $arguments = $common_arguments + array(
      'description' => t('Migration of profile fields from Drupal 6'),
      'machine_name' => 'FieldProfile',
      'dependencies' => array(
        'ContentType'
      ),
      'group' => MigrateGroup::getInstance('fields')
    );
    // We just use the migrate_d2d D6 migration class as-is.
    Migration::registerMigration('DrupalFieldProfileMigration', $arguments['machine_name'], $arguments);
    $user_dependencies[] = $arguments['machine_name'];
  }
  /*********************************************************************************************
       * Profile CCK fields
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of profile CCK fields from Drupal 6'),
    'machine_name' => 'FieldContentProfile',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldContentProfileMigration', $arguments['machine_name'], $arguments);
  $user_dependencies[] = $arguments['machine_name'];
  /*********************************************************************************************
     * Profile body field
    ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of profile body field from Drupal 6'),
    'machine_name' => 'FieldContentProfileBody',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldContentProfileBodyMigration', $arguments['machine_name'], $arguments);
  $user_dependencies[] = $arguments['machine_name'];
  /*********************************************************************************************
       * Image fields
       ********************************************************************************************/
  // Special handling for image fields
  $arguments = $common_arguments + array(
    'description' => t('Migration of image fields from Drupal 6'),
    'machine_name' => 'FieldImage',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldImageMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Image taxonomy fields
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of taxonomy fields from Drupal 6'),
    'machine_name' => 'FieldImageTaxonomy',
    'dependencies' => array(
      'ContentType',
      'Vocabulary'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  Migration::registerMigration('DrupalFieldImageTaxonomyMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Attached file field
       ********************************************************************************************/
  // The description and the migration machine name are also required arguments,
  // which will be unique for each migration you register.
  $arguments = $common_arguments + array(
    'description' => t('Migration of fields from Drupal 6'),
    'machine_name' => 'FieldFileAttachment',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldFileAttachmentMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Backreference field
  ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of backreference fields from Drupal 6'),
    'machine_name' => 'FieldBackreference',
    'dependencies' => array(
      'ContentType'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  Migration::registerMigration('DrupalFieldBackreferenceMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
       * Field groups
       ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of field groups from Drupal 6'),
    'machine_name' => 'FieldGroup',
    'dependencies' => array(
      'Field',
      'FieldBody',
      'FieldTaxonomy'
    ),
    'group' => MigrateGroup::getInstance('fields')
  );
  // We just use the migrate_d2d D6 migration class as-is.
  Migration::registerMigration('DrupalFieldGroupMigration', $arguments['machine_name'], $arguments);
  $common_file_arguments = $common_arguments + array(
    'dependencies' => array(
      'User',
      'Language'
    ),
    'group' => MigrateGroup::getInstance('files')
  );
  // Define node arguments here so all term migrations can be added as depenencies
  $common_node_arguments = $common_arguments + array(
    'user_migration' => 'User',
    'default_uid' => 0,
    'dependencies' => array( // Content types & fields must be migrated first 
      'ContentType',
      'Field',
      'FieldBody',
      'FieldTaxonomy',
      'FieldGroup',
      'User',
      'Vocabulary',
      'File',
      'Image',
      'Language'
    ),
    'group' => MigrateGroup::getInstance('content', array(
      'terms'
    ))
  );
  /*********************************************************************************************
   * Terms
   ********************************************************************************************/
  $common_term_arguments = $common_arguments + array(
    'dependencies' => $term_dependencies,
    'group' => MigrateGroup::getInstance('terms', array(
      'files'
    ))
  );
  // Get vocabularies to register the term migrations
  $query = Database::getConnection('default', 'scratchpad_1')->select('vocabulary', 'v');
  $query->fields('v', array(
    'vid',
    'name'
  ));
  $query->condition('module', array(
    'forum',
    'scratchpadify',
    'taxonomy'
  ), 'IN');
  $query->condition('vid', scratchpads_migrate_get_image_gallery_vid(), '!=');
  $query->condition('name', '', '!=');
  $vocabularies = $query->execute();
  foreach($vocabularies as $vocabulary){
    $arguments = array(
      'class_name' => 'ScratchpadTermMigration',
      'description' => t('Migration of %name terms from Drupal 6', array(
        '%name' => $vocabulary->name
      )),
      'machine_name' => scratchpads_migrate_get_machine_name('Term', $vocabulary->name),
      'source_vocabulary' => $vocabulary->vid,
      'destination_vocabulary' => $vocabulary->vid
    );
    $arguments = array_merge_recursive($arguments, $common_term_arguments);
    Migration::registerMigration($arguments['class_name'], $arguments['machine_name'], $arguments);
    $common_node_arguments['dependencies'][] = $arguments['machine_name'];
    $common_file_arguments['dependencies'][] = $arguments['machine_name'];
  }
  /*********************************************************************************************
   * Image galleries
  ********************************************************************************************/
  $arguments = $common_file_arguments + array(
    'description' => t('Migration of image galleries from Drupal 6'),
    'machine_name' => 'ImageGallery'
  );
  Migration::registerMigration('DrupalImageGalleryMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Files
  ********************************************************************************************/
  $arguments = $common_file_arguments + array(
    'description' => t('Migration of files from Drupal 6'),
    'machine_name' => 'File'
  );
  Migration::registerMigration('DrupalFileMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Images
  ********************************************************************************************/
  $common_file_arguments['dependencies'][] = 'ImageGallery';
  $arguments = $common_file_arguments + array(
    'description' => t('Migration of images from Drupal 6'),
    'machine_name' => 'Image'
  );
  Migration::registerMigration('DrupalImageMigration', $arguments['machine_name'], $arguments);
  /****************************************************************************
   * Dependencies for the PathRedirect migration
   ****************************************************************************/
  $path_dependencies = array();
  /*********************************************************************************************
   * Nodes
   ********************************************************************************************/
  // Create the organic groups migration class seperately so other nodes can be made dependent
  if(scratchpads_migrate_source_table_exists('og')){
    $arguments = array(
      'class_name' => 'ScratchpadsNodeOrganicGroupMigration',
      'description' => t('Migration of %type nodes from Drupal 6', array(
        '%type' => 'group'
      )),
      'machine_name' => 'OrganicGroup',
      'source_type' => 'group',
      'destination_type' => 'group'
    );
    $arguments = array_merge_recursive($arguments, $common_node_arguments);
    Migration::registerMigration($arguments['class_name'], $arguments['machine_name'], $arguments);
    $common_node_arguments['dependencies'][] = 'OrganicGroup';
  }
  $mappings = DrupalContentTypeMigration::getContentTypeMappings();
  // Get unmapped node types (custom content types on site)
  $query = Database::getConnection('default', 'scratchpad_1')->select('node_type', 'nt');
  $query->addField('nt', 'type');
  $query->condition('nt.type', array_keys($mappings), 'NOT IN');
  $result = $query->execute();
  foreach($result as $unmapped_node_type){
    $mappings[$unmapped_node_type->type] = MIGRATE_ALL;
  }
  $source_node_types = scratchpads_migrate_source_node_types();
  $all_node_dependencies = array();
  foreach($mappings as $type => $mapping){
    // Skip if we don't want to migrate this content type
    if($mapping == MIGRATE_NONE || $mapping == MIGRATE_FIELD){
      continue;
    }
    // Check we have a source node of this type
    if(!in_array($type, $source_node_types)){
      continue;
    }
    if(is_array($mapping)){
      if(isset($mapping['entity_type']) && $mapping['entity_type'] != 'node'){
        // Only do nodes at the moment
        continue;
      }
      if(isset($mapping['bundle'])){
        $destination_type = $mapping['bundle'];
      }
    }else{
      $destination_type = $type;
    }
    // Allow individual node type handlers
    $class_name = 'ScratchpadsNode' . ucfirst($type) . 'Migration';
    if(!class_exists($class_name)){
      $class_name = 'ScratchpadsNodeMigration';
    }
    $node_migration = ucfirst($type);
    // Create the arguments array from the mapping
    $arguments = array(
      'class_name' => $class_name,
      'description' => t('Migration of %type nodes from Drupal 6', array(
        '%type' => $type
      )),
      'machine_name' => $node_migration,
      'source_type' => $type,
      'destination_type' => $destination_type
    );
    $path_dependencies[] = $arguments['machine_name'];
    $all_node_dependencies[] = $arguments['machine_name'];
    $arguments = array_merge_recursive($arguments, $common_node_arguments);
    if($type == 'darwincore'){
      $arguments['dependencies'][] = 'Darwincorelocation';
    }
    Migration::registerMigration($arguments['class_name'], $arguments['machine_name'], $arguments);
    /*********************************************************************************************
     * Profile
    ********************************************************************************************/
    $arguments = array(
      'description' => t('Migration of profile-only users from Drupal 6'),
      'machine_name' => 'Profile',
      'source_type' => 'profile'
    );
    $arguments = array_merge_recursive($arguments, $common_node_arguments);
    Migration::registerMigration('ScratchpadsProfileMigration', $arguments['machine_name'], $arguments);
    /*********************************************************************************************
     * Comments
     ********************************************************************************************/
    // Comments are registered per node
    $arguments = $common_arguments + array(
      'description' => t('Migration of comments from Drupal 6'),
      'machine_name' => $node_migration . 'Comments',
      'node_migration' => $node_migration,
      'user_migration' => 'User',
      'destination_type' => $destination_type,
      'source_type' => $type,
      'group' => MigrateGroup::getInstance('content')
    );
    Migration::registerMigration('ScratchpadsCommentMigration', $arguments['machine_name'], $arguments);
    $all_node_dependencies[] = $arguments['machine_name'];
  }
  /*********************************************************************************************
   * Field Collections
   ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migrate fields that become field collections'),
    'machine_name' => 'FieldCollections',
    'group' => MigrateGroup::getInstance('content'),
    'dependencies' => $all_node_dependencies
  );
  Migration::registerMigration('FieldCollectionMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * PathRedirect
   ********************************************************************************************/
  if(scratchpads_migrate_source_table_exists('path_redirect')){
    $arguments = $common_arguments + array(
      'description' => t('Migration of URL redirects from Drupal 6'),
      'machine_name' => 'PathRedirect',
      'dependencies' => $path_dependencies,
      'group' => MigrateGroup::getInstance('final')
    );
    Migration::registerMigration('PathRedirectMigration', $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
   * Femail
   ********************************************************************************************/
  if(scratchpads_migrate_source_module_exists('femail')){
    // Do not enable Femail now - wait until after forums have been migrated
    $arguments = $common_arguments + array(
      'description' => t('Migration of Femail mappings'),
      'machine_name' => 'Femail',
      'dependencies' => $all_node_dependencies,
      'group' => MigrateGroup::getInstance('final')
    );
    Migration::registerMigration('FemailMigration', $arguments['machine_name'], $arguments);
    $arguments = $common_arguments + array(
      'description' => t('Migration of Femail user emails'),
      'machine_name' => 'FemailEmail',
      'dependencies' => $all_node_dependencies,
      'group' => MigrateGroup::getInstance('final')
    );
    Migration::registerMigration('FemailEmailMigration', $arguments['machine_name'], $arguments);
    $arguments = $common_arguments + array(
      'description' => t('Migration of Femail user subscriptions'),
      'machine_name' => 'FemailSubscription',
      'dependencies' => $all_node_dependencies,
      'group' => MigrateGroup::getInstance('final')
    );
    Migration::registerMigration('FemailSubscriptionMigration', $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
   * Menu
  ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of menus from Drupal 6'),
    'machine_name' => 'Menu',
    'dependencies' => $path_dependencies,
    'group' => MigrateGroup::getInstance('final')
  );
  Migration::registerMigration('ScrachpadsMenuMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Menu Links
  ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of menu items from Drupal 6'),
    'machine_name' => 'MenuLink',
    'dependencies' => $path_dependencies,
    'group' => MigrateGroup::getInstance('final'),
    'menu_migration' => 'Menu'
  );
  Migration::registerMigration('ScratchpadMenuLinkMigration', $arguments['machine_name'], $arguments);
  /*********************************************************************************************
   * Webform
  *********************************************************************************************/
  if (scratchpads_migrate_source_module_exists('webform')){
    if (!module_exists('webform')){
      module_enable(array(
        'webform'
      ));
    }
    $arguments = $common_arguments + array(
      'description' => t('Migration of Webform settings and submissions from Drupal 6'),
      'machine_name' => 'WebformSettings',
      'dependencies' => $all_node_dependencies,
      'group' => MigrateGroup::getInstance('final')
    );
    Migration::registerMigration('ScratchpadsWebformMigration', $arguments['machine_name'], $arguments);
  }
  /*********************************************************************************************
   * Blocks
  ********************************************************************************************/
  $arguments = $common_arguments + array(
    'description' => t('Migration of blocks from Drupal 6'),
    'machine_name' => 'Blocks',
    'dependencies' => array(
      'File', // Files must be migrated first
      'Image',
      'Menu',
      'MenuLink'
    ),
    'group' => MigrateGroup::getInstance('final', array(
      'content'
    ))
  );
  Migration::registerMigration('BlockMigration', $arguments['machine_name'], $arguments);
}

function scratchpads_migrate_get_term_vocabularies(){
  $term_vocabularies = scratchpads_migrate_variable_get('term_node_vocabularies-contenttypes');
  if(empty($term_vocabularies)){
    return array();
  }else{
    return array_filter($term_vocabularies);
  }
}

/**
 * Get a variable from the old DB
 * @param string $name
 */
function scratchpads_migrate_variable_get($name){
  $query = Database::getConnection('default', 'scratchpad_1')->select('variable', 'v');
  $query->addField('v', 'value');
  $query->condition('name', $name);
  return unserialize($query->execute()->fetchField());
}

/**
 * Load all terms indexed by TID by vocabulary ID
 * @param string $name
 */
function scratchpads_migrate_get_terms($name){
  $query = Database::getConnection('default', 'scratchpad_1')->select('term_data', 'td');
  $query->fields('td', array(
    'tid',
    'name'
  ));
  $query->innerJoin('vocabulary', 'v', 'v.vid = td.vid');
  $query->condition('v.name', $name);
  return $query->execute()->fetchAllKeyed();
}

function scratchpads_migrate_get_image_gallery_vid(){
  if(!$vid = scratchpads_migrate_variable_get('image_gallery_vid')){
    $query = Database::getConnection('default', 'scratchpad_1')->select('vocabulary', 'v');
    $query->addField('v', 'vid');
    $query->condition('name', 'Image Galleries');
    $vid = $query->execute()->fetchField();
  }
  return $vid;
}

function scratchpads_migrate_source_table_exists($table){
  $query = Database::getConnection('default', 'scratchpad_1')->query("SHOW TABLES LIKE '{$table}'");
  return $query->rowCount();
}

function scratchpads_migrate_source_table_not_empty($table){
  if(!scratchpads_migrate_source_table_exists($table)){return FALSE;}
  $query = Database::getConnection('default', 'scratchpad_1')->select($table, 't');
  $query->addExpression('COUNT(*)');
  return $query->execute()->fetchField() > 0;
}

function scratchpads_migrate_source_node_exists($nid){
  $query = Database::getConnection('default', 'scratchpad_1')->select('node', 'n');
  $query->addExpression('COUNT(*)');
  $query->condition('nid', $nid);
  return $query->execute()->fetchField() > 0;
}

function scratchpads_migrate_source_node_types(){
  $query = Database::getConnection('default', 'scratchpad_1')->select('node_type', 'nt');
  $query->addField('nt', 'type');
  $query->distinct();
  return $query->execute()->fetchCol();
}

function scratchpads_migrate_source_get_vid($nid){
  $query = Database::getConnection('default', 'scratchpad_1')->select('node', 'n');
  $query->addField('n', 'vid');
  $query->condition('nid', $nid);
  return $query->execute()->fetchField();
}

function scratchpads_migrate_source_biological_classifications(){
  $query = Database::getConnection('default', 'scratchpad_1')->select('scratchpads_migrate_biological_classification', 'b');
  $query->addField('b', 'vid');
  return $query->execute()->fetchCol();
}

function scratchpads_migrate_get_class_name($machine_name){
  return 'Drupal' . $machine_name . 'Migration';
}

function scratchpads_migrate_get_machine_name($type, $name){
  // Make sure the type is uppercase
  $type = ucwords($type);
  // Format the name
  $name = ucwords(str_replace('_', ' ', $name));
  $name = preg_replace('/[^a-zA-Z0-9]/', '', $name);
  return $type . $name;
}

function scratchpads_migrate_destination_node_type_exists($node_type){
  static $types = array();
  if(empty($types)){
    $types = node_type_get_types();
  }
  return array_key_exists($node_type, $types);
}

function scratchpads_migrate_unset_empty_fields($object, $skip = array('uid', 'comment', 'weight_weight', 'sticky', 'status', 'promote', 'moderate', 'field_weight', 'field_sticky', 'biblio_keywords')){
  // Loop through and unset NULL fields, otherwise they are populated with empty values
  $properties = array_keys((array)$object);
  foreach($properties as $property){
    if(in_array($property, $skip)){
      continue;
    }
    if((is_array($object->{$property}) && array_key_exists(0, $object->{$property}) && empty($object->{$property}[0])) || empty($object->{$property})){
      unset($object->{$property});
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function scratchpads_migrate_menu(){
  $items = array();
  $items['admin/content/migrate/status'] = array(
    'title' => 'Scratchpads',
    'type' => MENU_LOCAL_TASK,
    'description' => 'View all error messages',
    'page callback' => 'scratchpads_migrate_status_page',
    'access arguments' => array(
      MIGRATE_ACCESS_BASIC
    ),
    'weight' => 10
  );
  // For managing different types of media and the fields associated with them.
  $items['admin/config/content/scratchpads-migrate'] = array(
    'title' => 'Scratchpads post-migration tasks',
    'description' => 'Scratchpads migrate overview.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'scratchpads_migrate_overview_form'
    ),
    'access arguments' => array(
      'administer site configuration'
    ),
    'file' => 'scratchpads_migrate.admin.inc'
  );
  // For managing different types of media and the fields associated with them.
  $items['admin/config/content/scratchpads-migrate/error'] = array(
    'title' => 'Scratchpads migrate errors',
    'description' => 'Follow up tasks for scratchpads migrate.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'scratchpads_migrate_error_form'
    ),
    'access arguments' => array(
      'administer site configuration'
    ),
    'file' => 'scratchpads_migrate.admin.inc'
  );
  return $items;
}

function scratchpads_migrate_status_page(){
  $output = '';
  $migrations = migrate_migrations();
  //   foreach(array_keys($migrations) as $key){
  //     if($key == 'FieldVocabularyItisTerm13'){
  //       continue;
  //     }
  //     unset($migrations[$key]);
  //   }
  $error = false;
  foreach($migrations as $migration_name => $migration){
    if(method_exists($migration, 'sourceCount')){
      $total = $migration->sourceCount();
      // If we don't have any records don't validate the migration
      // Field migrations throw missing source field errors if there are no records to
      if($total == 0){
        continue;
      }
    }
    $items = array();
    $has_mappings = method_exists($migration, 'getFieldMappings');
    $destination = $migration->getDestination();
    $destination_fields = $destination->fields($migration);
    $source = $migration->getSource();
    $source_key = $migration->getMap()->getSourceKey();
    $source_fields = $source->fields();
    if($has_mappings){
      $field_mappings = $migration->getFieldMappings();
      $mapped_destination_fields = array();
      $mapped_source_fields = array();
      foreach(array_keys($source_key) as $key){
        $mapped_destination_fields[] = $key;
        $mapped_source_fields[] = $key;
      }
      foreach($field_mappings as $mapping){
        // Validate source and destination fields actually exist
        $source_field = $mapping->getSourceField();
        $mapped_source_fields[] = $source_field;
        $destination_field = $mapping->getDestinationField();
        $mapped_destination_fields[] = $destination_field;
        if(!is_null($source_field) && !isset($source_fields[$source_field])){
          $items[] = t('"!source" was used as source field in the
          "!destination" mapping but is not in list of source fields', array(
            '!source' => $source_field,
            '!destination' => $destination_field
          ));
        }
        if(!is_null($destination_field) && !isset($destination_fields[$destination_field])){
          $items[] = t('"!destination" was used as destination field in
          "!source" mapping but is not in list of destination fields', array(
            '!source' => $source_field,
            '!destination' => $destination_field
          ));
        }
      }
      // Check for any missing destination fields
      $unmapped_destination_fields = array_diff(array_keys($destination_fields), $mapped_destination_fields);
      if(count($unmapped_destination_fields)){
        foreach($unmapped_destination_fields as $unmapped_destination_field){
          drupal_set_message(t('Destination field "!migration.!destination" is unmapped', array(
            '!migration' => $migration_name,
            '!destination' => $unmapped_destination_field
          )), 'error');
          $error = true;
        }
      }
      // Check for any missing source fields
      $unmapped_source_fields = array_diff(array_keys($source_fields), $mapped_source_fields);
      if(count($unmapped_source_fields)){
        foreach($unmapped_source_fields as $unmapped_source_field){
          drupal_set_message(t('Source field "!migration.!destination" is unmapped', array(
            '!migration' => $migration_name,
            '!destination' => $unmapped_source_field
          )), 'error');
          $error = true;
        }
      }
    }
    if(count($items)){
      $output .= theme('item_list', array(
        'items' => $items,
        'title' => $migration->getMachineName()
      ));
    }
  }
  if($error){
    $output = "ERRORS";
  }else if(strlen($output) == 0){
    $output = 'WOOP WOOP WOOP';
  }
  return $output;
}

/**
 * The migration field contains the itis NID - need to map it to the tid
 * @param nid $destination_values
 * @return tid
 */
function scratchpads_migrate_itis_noderef_get_tid($nid){
  // We know the nid at this point - but we need to get the tid
  $query = Database::getConnection('default', 'scratchpad_1')->select('term_node', 'tn');
  $query->addField('tn', 'tid');
  $query->condition('tn.nid', $nid);
  $tid = $query->execute()->fetchField();
  return $tid;
}

function scratchpads_migrate_source_module_exists($module){
  // We know the nid at this point - but we need to get the tid
  $query = Database::getConnection('default', 'scratchpad_1')->select('system', 's');
  $query->addExpression('COUNT(*)');
  $query->condition('name', $module);
  $query->condition('type', 'module');
  $query->condition('status', 1);
  return $query->execute()->fetchField();
}

/**
 * Field APi doesn't allow you to update field entity type
 * Clone of field_update_field() with the entity type check removed
 */
function scratchpads_migrate_update_field_entity_type($field){
  // Check that the specified field exists.
  $prior_field = field_read_field($field['field_name']);
  if(empty($prior_field)){throw new FieldException('Attempt to update a non-existent field.');}
  // Use the prior field values for anything not specifically set by the new
  // field to be sure that all values are set.
  $field += $prior_field;
  $field['settings'] += $prior_field['settings'];
  // Some updates are always disallowed.
  if($field['type'] != $prior_field['type']){throw new FieldException("Cannot change an existing field's type.");}
  if($field['storage']['type'] != $prior_field['storage']['type']){throw new FieldException("Cannot change an existing field's storage type.");}
  // Collect the new storage information, since what is in
  // $prior_field may no longer be right.
  module_load_install($field['module']);
  $schema = (array)module_invoke($field['module'], 'field_schema', $field);
  $schema += array(
    'columns' => array(),
    'indexes' => array()
  );
  // 'columns' are hardcoded in the field type.
  $field['columns'] = $schema['columns'];
  // 'indexes' can be both hardcoded in the field type, and specified in the
  // incoming $field definition.
  $field += array(
    'indexes' => array()
  );
  $field['indexes'] += $schema['indexes'];
  $has_data = field_has_data($field);
  // See if any module forbids the update by throwing an exception.
  foreach(module_implements('field_update_forbid') as $module){
    $function = $module . '_field_update_forbid';
    $function($field, $prior_field, $has_data);
  }
  // Tell the storage engine to update the field. Do this before
  // saving the new definition since it still might fail.
  $storage_type = field_info_storage_types($field['storage']['type']);
  module_invoke($storage_type['module'], 'field_storage_update_field', $field, $prior_field, $has_data);
  // Save the new field definition. @todo: refactor with
  // field_create_field.
  // The serialized 'data' column contains everything from $field that does not
  // have its own column and is not automatically populated when the field is
  // read.
  $data = $field;
  unset($data['columns'], $data['field_name'], $data['type'], $data['locked'], $data['module'], $data['cardinality'], $data['active'], $data['deleted']);
  // Additionally, do not save the 'bundles' property populated by
  // field_info_field().
  unset($data['bundles']);
  $field['data'] = $data;
  // Store the field and create the id.
  $primary_key = array(
    'id'
  );
  drupal_write_record('field_config', $field, $primary_key);
  // Clear caches
  field_cache_clear(TRUE);
  // Invoke external hooks after the cache is cleared for API consistency.
  module_invoke_all('field_update_field', $field, $prior_field, $has_data);
}

/**
 * Insert a task
 */
function scratchpads_migrate_task_insert($entity_type, $entity_id, $error, $action){
  $task = new stdClass();
  $task->entity = $entity_type;
  $task->entity_id = $entity_id;
  $task->error = $error;
  $task->action = $action;
  drupal_write_record('scratchpads_migrate_task', $task);
}

/**
 * Insert a task
 */
function scratchpads_migrate_task_delete($entity_type, $entity_id){
  db_delete('scratchpads_migrate_task')->condition('entity', $entity_type)->condition('entity_id', $entity_id)->execute();
}

/**
 * Implementation of hook_mail
 */
function scratchpads_migrate_mail($key, &$message, $params){
  $message = array_merge($message, $params);
}

/**
 * Rewritten node_save(), preserving the VID
 *
 * @param $node
 *   The $node object to be saved. If $node->nid is
 *   omitted (or $node->is_new is TRUE), a new node will be added.
 */
function scratchpads_migrate_node_save($node, $revision_only = FALSE){
  $transaction = db_transaction();
  try{
    // Load the stored entity, if any.
    if(!empty($node->nid) && !isset($node->original)){
      $node->original = entity_load_unchanged('node', $node->nid);
    }
    field_attach_presave('node', $node);
    global $user;
    // Determine if we will be inserting a new node.
    if(!isset($node->is_new)){
      $node->is_new = empty($node->nid);
    }
    // Set the timestamp fields.
    if(empty($node->created)){
      $node->created = REQUEST_TIME;
    }
    // The changed timestamp is always updated for bookkeeping purposes,
    // for example: revisions, searching, etc.
    $node->changed = REQUEST_TIME;
    $node->timestamp = REQUEST_TIME;
    $update_node = TRUE;
    // Let modules modify the node before it is saved to the database.
    module_invoke_all('node_presave', $node);
    module_invoke_all('entity_presave', $node, 'node');
    if($node->is_new || !empty($node->revision)){
      // When inserting either a new node or a new node revision, $node->log
      // must be set because {node_revision}.log is a text column and therefore
      // cannot have a default value. However, it might not be set at this
      // point (for example, if the user submitting a node form does not have
      // permission to create revisions), so we ensure that it is at least an
      // empty string in that case.
      // @todo: Make the {node_revision}.log column nullable so that we can
      // remove this check.
      if(!isset($node->log)){
        $node->log = '';
      }
    }elseif(!isset($node->log) || $node->log === ''){
      // If we are updating an existing node without adding a new revision, we
      // need to make sure $node->log is unset whenever it is empty. As long as
      // $node->log is unset, drupal_write_record() will not attempt to update
      // the existing database column when re-saving the revision; therefore,
      // this code allows us to avoid clobbering an existing log entry with an
      // empty one.
      unset($node->log);
    }
    // Removed this: we want to keep the VID when writing a new revision, so it keeps the same VID
    //     if (!$node->is_new && !empty($node->revision) && $node->vid) {
    //       $node->old_vid = $node->vid;
    //       unset($node->vid);
    //     }
    // Save the node and node revision.
    if($node->is_new){
      // For new nodes, save new records for both the node itself and the node
      // revision.
      if(!$revision_only){
        drupal_write_record('node', $node);
      }else{
        $update_node = FALSE;
      }
      _node_save_revision($node, $user->uid);
      $op = 'insert';
    }else{
      // For existing nodes, update the node record which matches the value of
      // $node->nid.
      if(!$revision_only){
        drupal_write_record('node', $node, 'nid');
      }else{
        $update_node = FALSE;
      }
      // Then, if a new node revision was requested, save a new record for
      // that; otherwise, update the node revision record which matches the
      // value of $node->vid.
      if(!empty($node->revision)){
        _node_save_revision($node, $user->uid);
      }else{
        _node_save_revision($node, $user->uid, 'vid');
        $update_node = FALSE;
      }
      $op = 'update';
    }
    if($update_node){
      // Ensures the new VID is applied
      db_update('node')->fields(array(
        'vid' => $node->vid
      ))->condition('nid', $node->nid)->execute();
    }
    // Call the node specific callback (if any). This can be
    // node_invoke($node, 'insert') or
    // node_invoke($node, 'update').
    node_invoke($node, $op);
    // Save fields.
    $function = "field_attach_$op";
    $function('node', $node);
    module_invoke_all('node_' . $op, $node);
    module_invoke_all('entity_' . $op, $node, 'node');
    // Update the node access table for this node. There's no need to delete
    // existing records if the node is new.
    $delete = $op == 'update';
    node_access_acquire_grants($node, $delete);
    // Clear internal properties.
    unset($node->is_new);
    unset($node->original);
    // Clear the static loading cache.
    entity_get_controller('node')->resetCache(array(
      $node->nid
    ));
    // Ignore slave server temporarily to give time for the
    // saved node to be propagated to the slave.
    db_ignore_slave();
  }
  catch(Exception $e){
    $transaction->rollback();
    watchdog_exception('node', $e);
    throw $e;
  }
}
