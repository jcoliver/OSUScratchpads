<?php
/**
 * @file
 * Harvest images from Morphbank for a selected vocabulary
 */

/**
 * The URL for the morphbank service; append 'request' for queries
 */
define("MORPHBANK_SERVICE", "http://services.morphbank.net/mb3/");
//define("MORPHBANK_SERVICE_REQUEST", "http://services.morphbank.net/mb3/request");
/**
 * The URL for morphbank records
 */
define("MORPHBANK_NET_URL", "http://morphbank.net/");
/**
 * The URL for morphbank images
 */
define("MORPHBANK_IMAGE_URL", "http://images.morphbank.net/");

/**
 * Implements hook_menu().
 */
function morphbank_harvest_menu() {
  // e.g. go to localhost/OSUScratchpads/morphbank_harvest to access the form
//  $items['morphbank_harvest'] = array(
  $items['admin/config/system/morphbank_harvest'] = array(
    'title' => 'Morphbank harvest',
    'description' => t('Harvests images from Morphbank for a given vocabulary'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('morphbank_harvest_form'),
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Define the form.
 */
function morphbank_harvest_form() {
  // Start by getting a list of all vocabularies, for select element
  $vocabularies = taxonomy_get_vocabularies();
  foreach ($vocabularies as $vocabulary) {
    $taxonomies['morphbank_harvest_' . $vocabulary->vid] = $vocabulary->name;
  }

  // Make the select element
  $form['vid'] = array( // the name of the field is 'vid'
    '#type' => 'select',
    '#title' => '',
    '#options' => $taxonomies,
    '#empty_option' => t('Select vocabulary'),
    '#required' => TRUE,
  );

  // How many images to save?  -1 means unlimited
  $form['maximages'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of images per taxon'),
    '#description' => t('(enter -1 for unlimited)'),
    '#default_value' => 10,
  );

  // Whether to search on 'unidentifieds'
  $form['searchunid'] = array(
    '#type' => 'checkbox',
    '#title' => t("Include 'unidentified' in search?"),
    '#description' => t("If checked, harvest will performed queries for any taxa with 'unidentified' in the name; if unchecked, harvest skips those terms."),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Harvest'),
  );
  return $form;
}

// TODO any additional validation?

/**
 * Post-validation action on when form is submitted
 */
function morphbank_harvest_form_submit($form, &$form_state) {
  // Find out how many images to save
  // TODO add check/validation for non-numeric values
  $maximages = -1;
  if ($form_state['values']['maximages'] > 0) {
    $maximages = $form_state['values']['maximages'];
  }

  // See if we are to skip the unidentifieds
  $search_unidentifieds = FALSE;
  if ($form_state['values']['searchunid'] == 1) {
    $search_unidentifieds = TRUE;
  }

  // get the selected vid
  $vid_string = $form_state['values']['vid'];
  $vid = str_replace('morphbank_harvest_', '', $vid_string);

  // get the corresponding taxonomy
  $taxonomy = taxonomy_get_tree($vid);
  if (!is_null($taxonomy) && count($taxonomy) > 0) {
    $terms = array();
    $problem = FALSE;
    $num_added = 0;
    $num_changed = 0;
    $num_deleted = 0;
    foreach ($taxonomy as $term) {
      $terms[$term->tid] = $term->name;
      $term_name = $term->name;
      // We now have an array of term names.
      // 1. Perform morphbank query  _query_morphbank
      // 2. Process response         _process_query (return array of image Morphbank IDs?)
      //      If no images, move to next term;
      //      if images, loop over $maximages of them
      // 3. Get images from Morphbank.  See commented out code in morphbank_from_id_form_submit
      //      Check to see if file already exists using original_filename and morphbank ID?
      //      If it isn't there save file  _write_morphbank_images
      //      After saving file, $file = file_save_data($image, $destination, FILE_EXISTS_RENAME);
      //      get the fid from the file object:
      //      fid = file->fid;
      // 4. File has been saved, now we need to see if any specimens of this taxon have morphbank_ids
      //      If not, move to next term;
      //      if so, loop over specimens until (morphbank_id matches) all specimens
      //      looked at without match
      // 5. If specimen with matching morphbank ID is found, add record to field_data_field_media
      //      See code in morphbank_from_id_form_submit

      // If this is unidentified, do we want to perform search?
      $skip = FALSE;
      if (!$search_unidentifieds) {
        // Want to skip unidentifieds, so see if the string is in the name
          if (strpos($term_name, 'unidentified') === FALSE) { // use === in case the name string starts with 'unidentified' (and would return zero, which would evaluate to TRUE for comparison 0 == FALSE )
            // No 'unidentified' in string, so go ahead and include
          } else {
            // Found the string, so we will skip the record
            $skip = TRUE;
          }
      }

      if (!$skip){
        // Make sure Morphbank is responsive
        if (file_get_contents(MORPHBANK_SERVICE)) {
          $responses = _query_morphbank($term_name, $maximages);

          if ($responses) { // The numReturned element was not empty
            // The query worked, so insert/update morphbank_query table
            // TODO: insert/update morphbank_query table; then get qid
            $qid;

            if ($responses === 0) { // No images were returned from query

            } else { // An array of SimpleXLMObjects returned
              foreach ($responses as $morphbank_response) {
                _process_response($morphbank_response, $term_name);

              }
            }

          } else { // The numReturned element wasn't found in the response
            $problem = TRUE;
          }


        } else {
          $problem = TRUE;
        }
      }
    }
    if ($problem) {
      drupal_set_message(t("There was a problem connecting to Morphbank's server; some images may not have been harvested."));
    } else {
      drupal_set_message(t('Morphbank harvest complete'));
    }
    drupal_set_message(t('@added images added', array('@added' => $num_added)));
    drupal_set_message(t('@changed images added', array('@changed' => $num_changed)));
    drupal_set_message(t('@deleted images added', array('@deleted' => $num_deleted)));

  } else {
    drupal_set_message(t('Empty vocabulary selected (vid = @vid)', array('@vid' => $vid)));
  }
}

/**
 * Peform Morphbank query on passed $term_name
 *
 * @param string $term_name
 *   The term name to perform Taxonomic name search on
 *
 * @param int $maximages
 *   The maximum number of images to return
 *
 * @return array
 *   If query was successful and returned objects, returns indexed array of XML objects correpsonding
 *   to 'object type = "Image"' elements in Morphbank response; if the numReturned was 0, returns the
 *   value 0; in the case of an unsuccessful query (or one in which the numReturned element was
 *   missing, returns FALSE.

 */
function _query_morphbank($term_name, $maximages) {
  $search_terms = array(
      'method' => 'taxon',
      'objecttype' => 'Image',
      'format' => 'svc',
      'taxonName' => $term_name,
      'limit' => $maximages,
  );

  // Encode the query parameters for URL
  $encoded_parameters = array();
  foreach ($search_terms as $key => $value) {
    $encoded_parameters[] = urlencode($key) . '=' . urlencode($value);
  }

  // Build the query string
  $query_string = implode('&', $encoded_parameters);

  // Build the url
  $request_url = MORPHBANK_SERVICE . 'request?' . $query_string;

  // Make the request
  $result = drupal_http_request($request_url);

  //TODO: deal with error codes here

  // Convert the 'data' object returned from drupal_http_request from string to an XML object
  $response_xml = simplexml_load_string($result->data);

  if (!is_null($response_xml->numReturned)) {
    $num_returned = (int) $response_xml->numReturned;
  }

//  $store_query = TRUE;
  if ($num_returned > 0) {
    $response_array = array();
    foreach ($response_xml->object as $object) {
      $obj_attributes = $object->attributes();
      if ($obj_attributes['type'] == "Image") {
        $response_array[] = $object;
      }
    }
  } elseif ($num_returned === 0) { // numReturned element was zero (the query went through, but no images returned
    $response_array = 0;
  } else { // No numReturned element, something probably went wrong
//    $store_query = FALSE;
    // TODO: deal with no response here
    return FALSE;
  }

//  if ($store_query) {
    // TODO: cache, if possible...maybe not
//  }
  return $response_array;
}

/**
 * Processes a XML object corresponding to a Morphbank image record.
 *
 * Extracts relevant element values from $response.  If this record (as identified
 *   by the Morphbank ID) is new (no record in morphbank_images table), it adds
 *   a record to the table; if the record is *not* new, checks the date of last
 *   modification (in the XML as dateLastModified element).  If the record has
 *   been updated on Morphbank since the last harvest (as recorded in
 *   morphbank_images.last_modified field), it updates the morphbank_images record.
 *
 * After comparing ages, if the record is new(er), retrieves the image file from
 *   Morphbank, renames the file, and saves the file to the public://morphbank
 *   directory.
 *
 * Regardless of age of record, retrieves fid of file (which may have just been
 *   created or updated) AND the Morphbank ID of the specimen record for the image.
 *   Checks to see:
 *     (1) If any Scratchpads Specimen/Observation nodes have the same Morphbank ID.
 *       If so, see if they are linked in the field_data_field_media table; if not,
 *       links them using entity wrapper.
 *     (2) If any Scratchpads Specimen/Observation nodes are linked to the image
 *       in the field_data_field_media table that do *not* have the same specimen
 *       Morphbank ID, removes links using entity wrapper
 *
 * @param SimpleXMLObject $response
 *   XML object correpsonding to 'object type = "Image"' element in a Morphbank response
 *
 * @param string $term_name
 *   The term name used for the query that produced this response, primarily used here
 *   to create file name
 */
function _process_response($response, $term_name) {
  // Want to retrieve the image id
  $source_id_element = $response->sourceId;
  $morphbank_image_id = (int) $source_id_element->morphbank;

  // See if we have a record for this image ID already
  $last_changed = $response->dateLastModified; //TODO: delete or change the name of this variable
  // Convert to Unix timestamp (seconds since Unix era)
  $last_changed_on_morphbank = date(strtotime($response->dateLastModified));

  $query_result = db_select('morphbank_images', 'm')->fields('m', array('mid', 'last_modified', 'fid'))->condition('morphbank_image_id', $morphbank_image_id);
  $on_disk = count($query_result) > 0;
  $get_file = TRUE;
  if ($on_disk) {
    foreach ($query_result as $one_result) {
      $last_changed_on_disk = $one_result->last_modified;
      // If timestamp is same age or younger, do not get the file from Morphbank
      if ($last_changed_on_disk >= $last_changed_on_morphbank) {
        $get_file = FALSE;
        $fid = $one_result->fid; // We may need this later
      }
    }
  }

  if ($get_file) {
    $original_filename = $response->originalFileName;
    $fid = _retrieve_morphbank_image($morphbank_image_id, $term_name, $original_filename);
  }

  if ($fid) {
    $morphbank_specimen = $response->specimen;
    $morphbank_specimen_id = (int) $morphbank_specimen->morphbank;
    // Either (1) file has been written or (2) the image did not need to be downloaded again, either way, we have the fid
    // Now need to check for adding links to Specimen/Observation nodes
    _update_specimen_links($fid, $morphbank_specimen_id);


    // Finally, check to see if any links to Specimen/Observation nodes need to be removed (say, for example, if the
    //   Morphbank specimen ID changed)
  }
}

/**
 * Retrieves a jpg image file from Morphbank for passed $morphbank_image_id and saves to
 *   public://morphbank directory.  Returns resultant fid on success, FALSE on failure.
 *
 * @param int $morphbank_image_id
 *   The Morphbank ID for the image to retrieve
 *
 * @param string $term_name
 *   The term name used for the query that produced this response, primarily used here
 *   to create file name
 *
 * @param string $original_filename
 *   The original name of the image file uploaded to Morphbank, primarily used here
 *   to create file name
 *
 * @return If a file is retrieved from Morphbank and saved to disk, returns the fid (int)
 *   of the file (as listed in file_managed table); if no file was saved, returns FALSE.
 */
function _retrieve_morphbank_image($morphbank_image_id, $term_name, $original_filename) {
  if ($morphbank_image_id > 0) {
    $image_location = MORPHBANK_IMAGE_URL . '?id=' . $morphbank_image_id . '&imgType=jpg';
    $destination_directory = variable_get('file_default_scheme', 'public') . '://morphbank';
    if (file_prepare_directory($destination_directory, FILE_CREATE_DIRECTORY)) {
      // For the file name, will want the taxonomic name, the morphbank id, and the original file name
      // Keeping this info will make it easier for users to find the files they are looking for

      // Replace whitespace with dashes for file name
      $name_string = preg_replace('/\s+/', '-', $term_name);
      // Replace plus sign with dashes
      $name_string = str_replace('+', '-', $name_string);
      $new_file_name = $name_string . '-' . $morphbank_image_id . '-' . $original_filename;

      if (strpos(strtolower($new_file_name), ".jpg") == 0) {
        // No .jpg, see if there's a jpeg
        if (strpos(strtolower($new_file_name), ".jpeg") == 0) {
          // No .jpeg, just append .jpg
          $new_file_name = $new_file_name . '.jpg';
        } else {
          // Replace .jpeg with .jpg
          $new_file_name = str_ireplace('.jpeg', '.jpg', $new_file_name);
        }
      }
      $destination = file_stream_wrapper_uri_normalize($destination_directory . '/' . $new_file_name);
      $image = file_get_contents($image_location);
      // This save sets status == 1
      $file = file_save_data($image, $destination, FILE_EXISTS_REPLACE); // Replaces file if already exists

      if (is_object($file)) {
        $fid = $file->fid;
        return $fid;
      }
    }
  }
  return FALSE;
}

function _update_specimen_links($fid, $morphbank_specimen_id) {
  if ($fid > 0 && $morphbank_specimen_id > 0) {
    $node_query = new EntityFieldQuery();
    $node_query->endityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'specimen_observation')
      ->fieldCondition('field_morphbank_specimen_id', 'value', $morphbank_specimen_id, '=');
    $node_result = $node_query->execute();

    if (count($node_result['node']) > 0) {
      $node_ids = array_keys($node_result['node']);
      $nid = $node_ids[0]; // TODO: A cludge?  Perhaps, but there should only be 0 or 1 Specimen/Observation node(s) with this Morphbank specimen ID
      $node = node_load($nid);
      $file = file_load($fid);

      if ($file) {
        $wrapper = entity_metadata_wrapper('node', $node);
        if ($wrapper) {
          $current_list = $wrapper->field_media->value();

          if (!$current_list) {
            $current_list = array();
          }

          //Make sure this file is not already attached to this node (via fid)
          $make_link = TRUE;
          foreach ($current_list as $list_item) {
            if ($fid == $list_item['fid']) { // There is already a link, so no need to update
              $make_link = FALSE;
              break;
            }
          }

          if ($make_link) {
            // Have to cast the file as an array before attaching it to node
            $file_as_array = (array)$file;
            // Have to add a 'display' element
            $file_as_array['display'] = 1;
            // Add this new file to current list
            $current_list[] = $file_as_array;

            $wrapper->field_media->set($current_list);
            $wrapper->save();
          }
        }
      }
    }
  }
}